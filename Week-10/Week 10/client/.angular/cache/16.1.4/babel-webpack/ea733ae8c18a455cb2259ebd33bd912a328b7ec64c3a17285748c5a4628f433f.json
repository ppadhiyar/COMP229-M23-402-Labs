{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { defer, of } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n// tslint:disable:no-bitwise\nlet JwtHelperService = /*#__PURE__*/(() => {\n  class JwtHelperService {\n    constructor(config = null) {\n      this.tokenGetter = config && config.tokenGetter || function () {};\n    }\n    urlBase64Decode(str) {\n      let output = str.replace(/-/g, '+').replace(/_/g, '/');\n      switch (output.length % 4) {\n        case 0:\n          {\n            break;\n          }\n        case 2:\n          {\n            output += '==';\n            break;\n          }\n        case 3:\n          {\n            output += '=';\n            break;\n          }\n        default:\n          {\n            throw new Error('Illegal base64url string!');\n          }\n      }\n      return this.b64DecodeUnicode(output);\n    }\n    // credits for decoder goes to https://github.com/atk\n    b64decode(str) {\n      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n      let output = '';\n      str = String(str).replace(/=+$/, '');\n      if (str.length % 4 === 1) {\n        throw new Error(`'atob' failed: The string to be decoded is not correctly encoded.`);\n      }\n      for (\n      // initialize result and counters\n      let bc = 0, bs, buffer, idx = 0;\n      // get next character\n      buffer = str.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n      // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n      }\n      return output;\n    }\n    b64DecodeUnicode(str) {\n      return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), c => {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(''));\n    }\n    decodeToken(token = this.tokenGetter()) {\n      if (token instanceof Promise) {\n        return token.then(t => this._decodeToken(t));\n      }\n      return this._decodeToken(token);\n    }\n    _decodeToken(token) {\n      if (!token || token === '') {\n        return null;\n      }\n      const parts = token.split('.');\n      if (parts.length !== 3) {\n        throw new Error(`The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.`);\n      }\n      const decoded = this.urlBase64Decode(parts[1]);\n      if (!decoded) {\n        throw new Error('Cannot decode the token.');\n      }\n      return JSON.parse(decoded);\n    }\n    getTokenExpirationDate(token = this.tokenGetter()) {\n      if (token instanceof Promise) {\n        return token.then(t => this._getTokenExpirationDate(t));\n      }\n      return this._getTokenExpirationDate(token);\n    }\n    _getTokenExpirationDate(token) {\n      let decoded;\n      decoded = this.decodeToken(token);\n      if (!decoded || !decoded.hasOwnProperty('exp')) {\n        return null;\n      }\n      const date = new Date(0);\n      date.setUTCSeconds(decoded.exp);\n      return date;\n    }\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n      if (token instanceof Promise) {\n        return token.then(t => this._isTokenExpired(t, offsetSeconds));\n      }\n      return this._isTokenExpired(token, offsetSeconds);\n    }\n    _isTokenExpired(token, offsetSeconds) {\n      if (!token || token === '') {\n        return true;\n      }\n      const date = this.getTokenExpirationDate(token);\n      offsetSeconds = offsetSeconds || 0;\n      if (date === null) {\n        return false;\n      }\n      return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n    getAuthScheme(authScheme, request) {\n      if (typeof authScheme === 'function') {\n        return authScheme(request);\n      }\n      return authScheme;\n    }\n  }\n  JwtHelperService.ɵfac = function JwtHelperService_Factory(t) {\n    return new (t || JwtHelperService)(i0.ɵɵinject(JWT_OPTIONS));\n  };\n  JwtHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: JwtHelperService,\n    factory: JwtHelperService.ɵfac\n  });\n  return JwtHelperService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst fromPromiseOrValue = input => {\n  if (input instanceof Promise) {\n    return defer(() => input);\n  }\n  return of(input);\n};\nlet JwtInterceptor = /*#__PURE__*/(() => {\n  class JwtInterceptor {\n    constructor(config, jwtHelper, document) {\n      this.jwtHelper = jwtHelper;\n      this.document = document;\n      this.standardPorts = ['80', '443'];\n      this.tokenGetter = config.tokenGetter;\n      this.headerName = config.headerName || 'Authorization';\n      this.authScheme = config.authScheme || config.authScheme === '' ? config.authScheme : 'Bearer ';\n      this.allowedDomains = config.allowedDomains || [];\n      this.disallowedRoutes = config.disallowedRoutes || [];\n      this.throwNoTokenError = config.throwNoTokenError || false;\n      this.skipWhenExpired = config.skipWhenExpired;\n    }\n    isAllowedDomain(request) {\n      const requestUrl = new URL(request.url, this.document.location.origin);\n      // If the host equals the current window origin,\n      // the domain is allowed by default\n      if (requestUrl.host === this.document.location.host) {\n        return true;\n      }\n      // If not the current domain, check the allowed list\n      const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port) ? ':' + requestUrl.port : ''}`;\n      return this.allowedDomains.findIndex(domain => typeof domain === 'string' ? domain === hostName : domain instanceof RegExp ? domain.test(hostName) : false) > -1;\n    }\n    isDisallowedRoute(request) {\n      const requestedUrl = new URL(request.url, this.document.location.origin);\n      return this.disallowedRoutes.findIndex(route => {\n        if (typeof route === 'string') {\n          const parsedRoute = new URL(route, this.document.location.origin);\n          return parsedRoute.hostname === requestedUrl.hostname && parsedRoute.pathname === requestedUrl.pathname;\n        }\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n        return false;\n      }) > -1;\n    }\n    handleInterception(token, request, next) {\n      const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n      if (!token && this.throwNoTokenError) {\n        throw new Error('Could not get token from tokenGetter function.');\n      }\n      let tokenIsExpired = of(false);\n      if (this.skipWhenExpired) {\n        tokenIsExpired = token ? fromPromiseOrValue(this.jwtHelper.isTokenExpired(token)) : of(true);\n      }\n      if (token) {\n        return tokenIsExpired.pipe(map(isExpired => isExpired && this.skipWhenExpired ? request.clone() : request.clone({\n          setHeaders: {\n            [this.headerName]: `${authScheme}${token}`\n          }\n        })), mergeMap(innerRequest => next.handle(innerRequest)));\n      }\n      return next.handle(request);\n    }\n    intercept(request, next) {\n      if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n        return next.handle(request);\n      }\n      const token = this.tokenGetter(request);\n      return fromPromiseOrValue(token).pipe(mergeMap(asyncToken => {\n        return this.handleInterception(asyncToken, request, next);\n      }));\n    }\n  }\n  JwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) {\n    return new (t || JwtInterceptor)(i0.ɵɵinject(JWT_OPTIONS), i0.ɵɵinject(JwtHelperService), i0.ɵɵinject(DOCUMENT));\n  };\n  JwtInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: JwtInterceptor,\n    factory: JwtInterceptor.ɵfac\n  });\n  return JwtInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet JwtModule = /*#__PURE__*/(() => {\n  class JwtModule {\n    constructor(parentModule) {\n      if (parentModule) {\n        throw new Error(`JwtModule is already loaded. It should only be imported in your application's main module.`);\n      }\n    }\n    static forRoot(options) {\n      return {\n        ngModule: JwtModule,\n        providers: [{\n          provide: HTTP_INTERCEPTORS,\n          useClass: JwtInterceptor,\n          multi: true\n        }, options.jwtOptionsProvider || {\n          provide: JWT_OPTIONS,\n          useValue: options.config\n        }, JwtHelperService]\n      };\n    }\n  }\n  JwtModule.ɵfac = function JwtModule_Factory(t) {\n    return new (t || JwtModule)(i0.ɵɵinject(JwtModule, 12));\n  };\n  JwtModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: JwtModule\n  });\n  JwtModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return JwtModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\n//# sourceMappingURL=auth0-angular-jwt.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}